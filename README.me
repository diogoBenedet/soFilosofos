xplica√ß√£o Detalhada
üîπ Importa√ß√£o das bibliotecas
import threading
import time
import random


threading ‚Üí permite criar e controlar threads (fil√≥sofos).

time ‚Üí usado para simular o tempo pensando ou comendo.

random ‚Üí adiciona varia√ß√£o no tempo de execu√ß√£o.

üîπ Cria√ß√£o dos Sem√°foros
NUM_FILOSOFOS = 5
hashis = [threading.Semaphore(1) for _ in range(NUM_FILOSOFOS)]
garcom = threading.Semaphore(NUM_FILOSOFOS - 1)

‚úî hashis

Cada hashi √© um sem√°foro que permite apenas 1 fil√≥sofo segur√°-lo por vez.

‚úî garcom

Um sem√°foro especial que s√≥ permite que 4 fil√≥sofos tentem pegar hashis ao mesmo tempo.

üéØ Isso impede que todos segurem um hashi simultaneamente, evitando deadlock.

üîπ Fun√ß√£o jantar()

Essa fun√ß√£o representa a vida de um fil√≥sofo.

1Ô∏è‚É£ Identifica√ß√£o dos hashis
esquerda = filosofo_id
direita = (filosofo_id + 1) % NUM_FILOSOFOS


Cada fil√≥sofo tem acesso ao hashi da esquerda e ao da direita.

O operador % faz a mesa ‚Äúdar a volta‚Äù.

2Ô∏è‚É£ Fil√≥sofo pensando
print(f"Fil√≥sofo {filosofo_id} est√° pensando.")
time.sleep(random.uniform(1, 3))


Simula um tempo de reflex√£o.

3Ô∏è‚É£ Fil√≥sofo sente fome
print(f"Fil√≥sofo {filosofo_id} est√° com fome.")


Agora ele tentar√° pegar dois hashis para comer.

4Ô∏è‚É£ Fil√≥sofo pede permiss√£o ao gar√ßom
garcom.acquire()


O gar√ßom impede que todos tentem comer ao mesmo tempo, prevenindo deadlock.

5Ô∏è‚É£ Pegar os dois hashis
hashis[esquerda].acquire()
print(f"Fil√≥sofo {filosofo_id} pegou o hashi esquerdo ({esquerda}).")

hashis[direita].acquire()
print(f"Fil√≥sofo {filosofo_id} pegou o hashi direito ({direita}).")


Como cada hashi √© um sem√°foro, ele s√≥ pode ser usado por um fil√≥sofo por vez.

6Ô∏è‚É£ Comer
print(f"Fil√≥sofo {filosofo_id} est√° comendo.")
time.sleep(random.uniform(1, 3))


Simula o tempo comendo.

7Ô∏è‚É£ Devolver os hashis e liberar o gar√ßom
hashis[esquerda].release()
hashis[direita].release()
print(f"Fil√≥sofo {filosofo_id} devolveu os hashis.")

garcom.release()


Assim outros fil√≥sofos podem tentar comer.

üßµ Cria√ß√£o das Threads
for i in range(NUM_FILOSOFOS):
    t = threading.Thread(target=jantar, args=(i,))
    t.start()


Cada fil√≥sofo √© uma thread que executa a fun√ß√£o jantar() de forma independente.

üõë Esperando as Threads Terminarem
for t in filosofos:
    t.join()


O programa principal espera (na pr√°tica, o c√≥digo roda em loop infinito).

üõ°Ô∏è Como o C√≥digo Evita Deadlock?

Deadlock ocorre quando:

cada fil√≥sofo segura 1 hashi

todos aguardam o segundo hashi

ningu√©m libera nenhum recurso

A solu√ß√£o do gar√ßom evita isso:

‚úî limita a 4 fil√≥sofos tentando comer
‚úî sempre sobra 1 par de hashis livre
‚úî sempre h√° progresso no sistema

üçΩÔ∏è Como o C√≥digo Evita Starvation?

hashis s√£o liberados rapidamente

todos t√™m chance de tentar novamente

nenhum fil√≥sofo fica preso esperando para sempre
